
import Foundation
import CoreImage

// python
import PyCoreVideo
import PySwiftKit
import PySwiftObject
import PySerializing
import PySwiftWrapper
import PyUnpack
extension CVBuffer: @unchecked Swift.Sendable {}

@PyClass
public class CameraBase {
    
    let camera = CameraBackend()

    @PyProperty
    var py_callback: CameraCallback?

    private var previewBufferSize: Int = 0
    
    var on_frame: (@MainActor (CVPixelBuffer) async -> Void)?
    var new_texture: (@MainActor (Int,Int) async -> Void)?
    
    @PyInit
    init() {
        Task {
            await handleCameraPreviews()
        }
    }
    
    @PyMethod
    func start(
        new_texture: @MainActor @escaping (Int, Int) async -> Void,
        on_frame: @MainActor @escaping (CVPixelBuffer) async -> Void
    ) {
        self.on_frame = on_frame
        self.new_texture = new_texture
        Task {
            await camera.start()
            
            //camera.switchCaptureDevice()
            
        }
    }
    
    @PyMethod
    func stop() {
        camera.stop()
    }
    
    @PyMethod
    func abc(a: PyPointer?, b: CameraCallback?, c: [Int], d: Int32, e: Double, f: String?) {
        print("abc")
    }

    @PyMethod
    func set_callback(callback: CameraCallback) {
        py_callback = callback
    }
    deinit {
        print(Self.self, "deinit")
    }
}

extension CameraBase {
    
    //@MainActor
//    func newPreviewTexture(h: Int, w: Int, buf_size: Int) async {
//        previewBufferSize = buf_size
//        await new_texture?(w, h)
////        guard let cb = py_callback else { return }
////        cb.new_texture(w: w, h: h)
//    }
//    
    
//    @MainActor
//    func sendPreviewToPython(pixels: CVPixelBuffer) async {
//        guard let cb = py_callback else { return }
//        cb.on_frame(buffer: pixels)
//    }
//    
    func handleCameraPreviews() async {
        let pixelStream = camera.previewStream
        for await pixels in pixelStream {
            
            await handleBufferSize(pixels: pixels)
            await on_frame?(pixels)
            //await sendPreviewToPython(pixels: pixels)

        }
    }
    
    func handleBufferSize(pixels: CVPixelBuffer) async {
        let newSize = CVPixelBufferGetDataSize(pixels)
        if newSize != previewBufferSize {
            let w = CVPixelBufferGetBytesPerRow(pixels) / 4
            let h = CVPixelBufferGetHeight(pixels)
            
            previewBufferSize = newSize
            await new_texture?(w, h)
            //await newPreviewTexture(h: h, w: w, buf_size: newSize)
        }
    }
}


@PyClass
@PyContainer
final class CameraCallback: PySerialize {
    
    @PyCall
    func new_texture(w: Int, h: Int)
    
    @PyCall
    func on_frame(buffer: CVPixelBuffer)
    
    var pyPointer: PyPointer {
        py_target.newRef
    }
    
}
    

@PyModule
struct IosCamera: PyModuleProtocol {
    
    @PyFunction
    static func cam() {
        
    }

    static var py_classes: [any (PyClassProtocol & AnyObject).Type] = [
        CameraCallback.self,
        CameraBase.self
    ]
}
                                                                    // vvvv generated by @PyModule
extension PySwiftModuleImport {
    public static let camera = PySwiftModuleImport(name: "ios_camera", module: IosCamera.py_init)
}
